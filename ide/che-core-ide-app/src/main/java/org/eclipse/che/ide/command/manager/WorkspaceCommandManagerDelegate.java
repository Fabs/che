/*******************************************************************************
 * Copyright (c) 2012-2016 Codenvy, S.A.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Codenvy, S.A. - initial API and implementation
 *******************************************************************************/
package org.eclipse.che.ide.command.manager;

import com.google.inject.Inject;
import com.google.inject.Singleton;

import org.eclipse.che.api.core.model.machine.Command;
import org.eclipse.che.api.machine.shared.dto.CommandDto;
import org.eclipse.che.api.promises.client.Function;
import org.eclipse.che.api.promises.client.FunctionException;
import org.eclipse.che.api.promises.client.Operation;
import org.eclipse.che.api.promises.client.OperationException;
import org.eclipse.che.api.promises.client.Promise;
import org.eclipse.che.api.promises.client.js.JsPromiseError;
import org.eclipse.che.api.promises.client.js.Promises;
import org.eclipse.che.api.workspace.shared.dto.WorkspaceDto;
import org.eclipse.che.ide.api.app.AppContext;
import org.eclipse.che.ide.api.command.CommandImpl;
import org.eclipse.che.ide.api.command.CommandManager2;
import org.eclipse.che.ide.api.command.CommandType;
import org.eclipse.che.ide.api.command.CommandTypeRegistry;
import org.eclipse.che.ide.api.workspace.WorkspaceServiceClient;
import org.eclipse.che.ide.dto.DtoFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.base.Strings.isNullOrEmpty;
import static org.eclipse.che.api.workspace.shared.Constants.COMMAND_PREVIEW_URL_ATTRIBUTE_NAME;

/**
 * Responsible for managing the commands which are stored with workspace.
 *
 * @author Artem Zatsarynnyi
 */
@Singleton
class WorkspaceCommandManagerDelegate {

    private final WorkspaceServiceClient workspaceServiceClient;
    private final AppContext             appContext;
    private final DtoFactory             dtoFactory;
    private final CommandTypeRegistry    commandTypeRegistry;

    private final Map<String, CommandImpl> workspaceCommands;

    @Inject
    WorkspaceCommandManagerDelegate(WorkspaceServiceClient workspaceServiceClient,
                                    AppContext appContext,
                                    DtoFactory dtoFactory,
                                    CommandTypeRegistry commandTypeRegistry) {
        this.workspaceServiceClient = workspaceServiceClient;
        this.appContext = appContext;
        this.dtoFactory = dtoFactory;
        this.commandTypeRegistry = commandTypeRegistry;

        workspaceCommands = new HashMap<>();

        fetchWorkspaceCommands();
    }

    private void fetchWorkspaceCommands() {
        workspaceServiceClient.getCommands(appContext.getWorkspaceId()).then(new Operation<List<CommandDto>>() {
            @Override
            public void apply(List<CommandDto> arg) throws OperationException {
                for (Command command : arg) {
                    workspaceCommands.put(command.getName(), new CommandImpl(command));
                }
            }
        });
    }

    /** Returns commands. */
    List<CommandImpl> getCommands() {
        // return copy of the commands in order to prevent it modification directly
        List<CommandImpl> list = new ArrayList<>(workspaceCommands.size());
        for (CommandImpl command : workspaceCommands.values()) {
            list.add(new CommandImpl(command));
        }

        return list;
    }

    /**
     * Creates new command of the specified type.
     * <p><b>Note</b> that command's name will be generated by {@link CommandManager2}
     * and command line will be provided by an appropriate {@link CommandType}.
     */
    Promise<CommandImpl> createCommand(String type) {
        final CommandType commandType = commandTypeRegistry.getCommandTypeById(type);

        if (commandType == null) {
            return Promises.reject(JsPromiseError.create("Unknown command type: " + type));
        }

        return createCommand(getUniqueCommandName(type, null),
                             commandType.getCommandLineTemplate(),
                             type,
                             new HashMap<String, String>());
    }

    /**
     * Creates new command with the specified arguments.
     * <p><b>Note</b> that name of the created command may differ from
     * the specified {@code desirableName} in order to prevent name duplication.
     */
    Promise<CommandImpl> createCommand(String desirableName,
                                       String commandLine,
                                       String type,
                                       Map<String, String> attributes) {
        final CommandType commandType = commandTypeRegistry.getCommandTypeById(type);

        if (commandType == null) {
            return Promises.reject(JsPromiseError.create("Unknown command type: " + type));
        }

        attributes.put(COMMAND_PREVIEW_URL_ATTRIBUTE_NAME, commandType.getPreviewUrlTemplate());

        return createCommand(new CommandImpl(getUniqueCommandName(type, desirableName),
                                             commandLine,
                                             type,
                                             attributes));
    }

    private Promise<CommandImpl> createCommand(final CommandImpl command) {
        final CommandDto commandDto = dtoFactory.createDto(CommandDto.class)
                                                .withName(command.getName())
                                                .withCommandLine(command.getCommandLine())
                                                .withType(command.getType())
                                                .withAttributes(command.getAttributes());

        return workspaceServiceClient.addCommand(appContext.getWorkspaceId(), commandDto).then(new Function<WorkspaceDto, CommandImpl>() {
            @Override
            public CommandImpl apply(WorkspaceDto arg) throws FunctionException {
                workspaceCommands.put(command.getName(), command);

                // TODO
//                notifyCommandAdded(command);

                return command;
            }
        });
    }

    /**
     * Updates the command with the specified {@code name} by replacing it with the given {@code command}.
     * <p><b>Note</b> that name of the updated command may differ from the name provided by the given {@code command}
     * in order to prevent name duplication.
     */
    Promise<CommandImpl> updateCommand(String name, CommandImpl command) {
        return null;
    }

    /** Removes the command with the specified {@code commandName}. */
    Promise<Void> removeCommand(String commandName) {
        return null;
    }

    /**
     * Returns {@code customName} if it's unique within the given {@code customType}
     * or newly generated name if it isn't unique within the given {@code customType}.
     */
    private String getUniqueCommandName(String customType, String customName) {
        final CommandType commandType = commandTypeRegistry.getCommandTypeById(customType);
        final Set<String> commandNames = workspaceCommands.keySet();

        final String newCommandName;

        if (isNullOrEmpty(customName)) {
            newCommandName = "new" + commandType.getDisplayName();
        } else {
            if (!commandNames.contains(customName)) {
                return customName;
            }
            newCommandName = customName + " copy";
        }

        if (!commandNames.contains(newCommandName)) {
            return newCommandName;
        }

        for (int count = 1; count < 1000; count++) {
            if (!commandNames.contains(newCommandName + "-" + count)) {
                return newCommandName + "-" + count;
            }
        }

        return newCommandName;
    }
}
